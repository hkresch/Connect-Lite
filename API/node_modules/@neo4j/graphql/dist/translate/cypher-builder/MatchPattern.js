"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchPattern = void 0;
const CypherASTNode_1 = require("./CypherASTNode");
const stringify_object_1 = require("../utils/stringify-object");
const Node_1 = require("./references/Node");
const Relationship_1 = require("./references/Relationship");
const utils_1 = require("./utils");
class MatchPattern extends CypherASTNode_1.CypherASTNode {
    constructor(input, options) {
        super();
        this.matchElement = input;
        this.parameters = {}; // Cast required due to neo-push
        this.options = { labels: true, relationshipTypes: true, ...options };
    }
    withParams(parameters) {
        this.parameters = parameters;
        return this;
    }
    cypher(context, childrenCypher) {
        if (childrenCypher)
            throw new Error("Match pattern cannot have children nodes");
        if (this.matchElement instanceof Node_1.Node) {
            return this.getNodeCypher(context, this.matchElement);
        }
        if (this.matchElement instanceof Relationship_1.Relationship) {
            return this.getRelationshipCypher(context, this.matchElement);
        }
        throw new Error("Invalid element in match pattern");
    }
    getRelationshipCypher(context, relationship) {
        const referenceId = context.getVariableId(relationship);
        const parameterOptions = this.parameters;
        const parameterStrs = {
            source: this.serializeParameters(parameterOptions.source || {}, context),
            relationship: this.serializeParameters(parameterOptions.relationship || {}, context),
            target: this.serializeParameters(parameterOptions.target || {}, context),
        };
        const labelsStr = {
            source: "",
            relationship: this.options.relationshipTypes ? relationship.getTypeString() : "",
            target: "",
        };
        if (this.options.labels) {
            labelsStr.source = relationship.source.getLabelsString();
            labelsStr.target = relationship.target.getLabelsString();
        }
        const sourceStr = `(${context.getVariableId(relationship.source)}${labelsStr.source}${parameterStrs.source})`;
        const targetStr = `(${context.getVariableId(relationship.target)}${labelsStr.target}${parameterStrs.target})`;
        const arrowStr = this.getRelationshipArrow(relationship);
        const relationshipStr = `${referenceId || ""}${labelsStr.relationship}${parameterStrs.relationship}`;
        return `${sourceStr}-[${relationshipStr}]${arrowStr}${targetStr}`;
    }
    getRelationshipArrow(relationship) {
        return relationship.directed ? "->" : "-";
    }
    getNodeCypher(context, node) {
        const referenceId = context.getVariableId(node);
        const parametersStr = this.serializeParameters(this.parameters, context);
        const nodeLabelString = this.options.labels ? node.getLabelsString() : "";
        return `(${referenceId}${nodeLabelString}${parametersStr})`;
    }
    serializeParameters(parameters, context) {
        if (Object.keys(this.parameters).length === 0)
            return "";
        const paramValues = Object.entries(parameters).reduce((acc, [key, param]) => {
            acc[key] = param.getCypher(context);
            return acc;
        }, {});
        return (0, utils_1.padLeft)((0, stringify_object_1.stringifyObject)(paramValues));
    }
}
exports.MatchPattern = MatchPattern;
//# sourceMappingURL=MatchPattern.js.map