"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const classes_1 = require("../../classes");
const create_connection_where_and_params_1 = __importDefault(require("./create-connection-where-and-params"));
const create_where_clause_1 = __importDefault(require("./create-where-clause"));
const utils_1 = require("./utils");
const apoc_run_1 = require("../utils/apoc-run");
const map_to_db_property_1 = __importDefault(require("../../utils/map-to-db-property"));
const list_predicate_to_clause_1 = require("./list-predicate-to-clause");
function createElementWhereAndParams({ whereInput, element, varName, context, parameterPrefix, listPredicates, }) {
    if (!Object.keys(whereInput).length) {
        return ["", {}];
    }
    function reducer(res, [key, value]) {
        const param = `${parameterPrefix}.${key}`;
        const match = utils_1.whereRegEx.exec(key);
        if (!match) {
            throw new Error(`Failed to match key in filter: ${key}`);
        }
        const { fieldName, operator } = match.groups;
        if (!fieldName) {
            throw new Error(`Failed to find field name in filter: ${key}`);
        }
        const isNot = operator?.startsWith("NOT") ?? false;
        const dbProperty = (0, map_to_db_property_1.default)(element, fieldName);
        const coalesceValue = [...element.primitiveFields, ...element.temporalFields, ...element.enumFields].find((f) => fieldName === f.fieldName)?.coalesceValue;
        const property = coalesceValue !== undefined
            ? `coalesce(${varName}.${dbProperty}, ${coalesceValue})`
            : `${varName}.${dbProperty}`;
        if (["AND", "OR"].includes(fieldName)) {
            const innerClauses = [];
            const nestedParams = [];
            value.forEach((v, i) => {
                const recurse = createElementWhereAndParams({
                    whereInput: v,
                    element,
                    varName,
                    context,
                    parameterPrefix: `${parameterPrefix}.${fieldName}[${i}]`,
                });
                innerClauses.push(`(${recurse[0]})`);
                nestedParams.push(recurse[1]);
            });
            res.clauses.push(`(${innerClauses.join(` ${fieldName} `)})`);
            res.params = { ...res.params, [fieldName]: nestedParams };
            return res;
        }
        if (element instanceof classes_1.Node) {
            const relationField = element.relationFields.find((x) => fieldName === x.fieldName);
            if (relationField) {
                const refNode = context.nodes.find((x) => x.name === relationField.typeMeta.name);
                const inStr = relationField.direction === "IN" ? "<-" : "-";
                const outStr = relationField.direction === "OUT" ? "->" : "-";
                const relTypeStr = `[:${relationField.type}]`;
                const relatedNodeVariable = `${varName}_${relationField.fieldName}`;
                const labels = refNode.getLabelString(context);
                const matchPattern = `(${varName})${inStr}${relTypeStr}${outStr}(${relatedNodeVariable}${labels})`;
                if (value === null) {
                    res.clauses.push(`${isNot ? "" : "NOT "}EXISTS { ${matchPattern} }`);
                    return res;
                }
                const recurse = createElementWhereAndParams({
                    whereInput: value,
                    element: refNode,
                    varName: relatedNodeVariable,
                    context,
                    parameterPrefix: `${parameterPrefix}.${fieldName}`,
                });
                if (recurse[0]) {
                    const listPredicate = (0, utils_1.getListPredicate)(operator);
                    const clause = (0, list_predicate_to_clause_1.listPredicateToClause)(listPredicate, matchPattern, recurse[0]);
                    res.clauses.push(clause);
                    res.params = { ...res.params, ...recurse[1] };
                }
                return res;
            }
            const connectionField = element.connectionFields.find((x) => fieldName === x.fieldName);
            if (connectionField) {
                let nodeEntries = value;
                if (!connectionField?.relationship.union) {
                    nodeEntries = { [connectionField.relationship.typeMeta.name]: value };
                }
                Object.entries(nodeEntries).forEach((entry) => {
                    const refNode = context.nodes.find((x) => x.name === entry[0]);
                    const relationship = context.relationships.find((x) => x.name === connectionField.relationshipTypeName);
                    const safeNodeVariable = `${varName.replace(/\./g, "_")}`;
                    const relatedNodeVariable = `${safeNodeVariable}_${refNode.name}`;
                    const inStr = connectionField.relationship.direction === "IN" ? "<-" : "-";
                    const relationshipVariable = `${relatedNodeVariable}_${connectionField.relationshipTypeName}`;
                    const outStr = connectionField.relationship.direction === "OUT" ? "->" : "-";
                    const labels = refNode.getLabelString(context);
                    const collectedMap = `${relatedNodeVariable}_map`;
                    const rootParam = parameterPrefix.split(".", 1)[0];
                    const existsStr = `exists((${safeNodeVariable})${inStr}[:${connectionField.relationship.type}]${outStr}(${labels}))`;
                    if (value === null) {
                        res.clauses.push(isNot ? `NOT ${existsStr}` : existsStr);
                        return;
                    }
                    const hasPreviousSinglePredicate = listPredicates?.length
                        ? listPredicates.includes("single")
                        : null;
                    const currentListPredicate = hasPreviousSinglePredicate ? "single" : (0, utils_1.getListPredicate)(operator);
                    const resultArr = [
                        `RETURN ${existsStr}`,
                        `AND ${currentListPredicate}(${collectedMap} IN [(${safeNodeVariable})${inStr}[${relationshipVariable}:${connectionField.relationship.type}]${outStr}(${relatedNodeVariable}${labels}) | { node: ${relatedNodeVariable}, relationship: ${relationshipVariable} } ] INNER_WHERE `,
                    ];
                    const connectionWhere = (0, create_connection_where_and_params_1.default)({
                        whereInput: entry[1],
                        context,
                        node: refNode,
                        nodeVariable: `${collectedMap}.node`,
                        relationship,
                        relationshipVariable: `${collectedMap}.relationship`,
                        parameterPrefix: `${parameterPrefix}.${fieldName}`,
                        // listPredicates stores all list predicates (SINGLE, ANY, NONE,..) while (recursively) translating the where clauses
                        listPredicates: [currentListPredicate, ...(listPredicates || [])],
                    });
                    resultArr.push(connectionWhere[0]);
                    resultArr.push(")"); // close NONE/ANY
                    const expectMultipleValues = listPredicates?.length ? !listPredicates.includes("single") : true;
                    const apocRunFirstColumn = (0, apoc_run_1.wrapInApocRunFirstColumn)(resultArr.join("\n"), {
                        [safeNodeVariable]: varName,
                        [rootParam]: `$${rootParam}`,
                    }, expectMultipleValues);
                    res.clauses.push(apocRunFirstColumn);
                    res.params = { ...res.params, [fieldName]: connectionWhere[1] };
                });
                return res;
            }
        }
        if (value === null) {
            res.clauses.push(`${property} ${isNot ? "IS NOT" : "IS"} NULL`);
            return res;
        }
        const pointField = element.pointFields.find((x) => x.fieldName === fieldName);
        const durationField = element.primitiveFields.find((x) => x.fieldName === fieldName && x.typeMeta.name === "Duration");
        res.clauses.push((0, create_where_clause_1.default)({ param, property, operator, isNot, pointField, durationField }));
        res.params[key] = value;
        return res;
    }
    const { clauses, params } = Object.entries(whereInput).reduce(reducer, { clauses: [], params: {} });
    const where = clauses.join(" AND ").replace(/INNER_WHERE/gi, "WHERE");
    return [where, params];
}
exports.default = createElementWhereAndParams;
//# sourceMappingURL=create-element-where-and-params.js.map